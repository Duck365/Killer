<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue vs Red: Slow-Mo Brawler</title>
    <style>
        body { background-color: #222; color: white; text-align: center; font-family: sans-serif; }
        canvas { background-color: #111; border: 2px solid #555; margin-top: 20px; box-shadow: 0 0 10px #000; }
        p { max-width: 600px; margin: 10px auto; line-height: 1.5; color: #aaa; }
    </style>
</head>
<body>

    <h2>Blue vs Red Box</h2>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <p><strong>Controls:</strong> WASD/Arrows to move and aim shield. W/Up to jump. <strong>Z</strong> to shoot. <strong>X</strong> to shield. <strong>R</strong> to reset.</p>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game Constants (based on your exact specs)
const MOVE_SPEED = 20; // 10px per 0.5s = 20px per second
const GRAVITY = 60;    // Reaches 0 velocity in 1 second
const JUMP_VELOCITY = -60; // Travels exactly 30px up in 1 second
const BULLET_SPEED = 150; // Made bullets a bit faster so they are threatening

let keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Game State
let player, enemy, bullets, platforms, lastTime;

function resetGame() {
    player = { x: 50, y: 300, w: 10, h: 10, vx: 0, vy: 0, hp: 5, facing: 'right', shielding: false, cooldown: 0, color: 'blue' };
    enemy = { x: 540, y: 300, w: 10, h: 10, vx: 0, vy: 0, hp: 5, facing: 'left', shielding: false, cooldown: 0, color: 'red', stateTimer: 0 };
    bullets = [];
    platforms = [
        { x: 0, y: 350, w: 600, h: 50 }, // Ground
        { x: 150, y: 280, w: 100, h: 10 },
        { x: 350, y: 280, w: 100, h: 10 },
        { x: 250, y: 200, w: 100, h: 10 }
    ];
}

function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
}

function updatePhysics(entity, dt) {
    // Horizontal Movement
    entity.x += entity.vx * dt;
    
    // Gravity and Vertical Movement
    entity.vy += GRAVITY * dt;
    entity.y += entity.vy * dt;

    // Platform Collisions
    entity.grounded = false;
    platforms.forEach(p => {
        if (rectIntersect(entity, p) && entity.vy > 0 && entity.y + entity.h - (entity.vy * dt) <= p.y + 1) {
            entity.y = p.y - entity.h;
            entity.vy = 0;
            entity.grounded = true;
        }
    });

    // Screen bounds
    if (entity.x < 0) entity.x = 0;
    if (entity.x + entity.w > canvas.width) entity.x = canvas.width - entity.w;
}

function shoot(entity) {
    if (entity.cooldown <= 0) {
        bullets.push({
            x: entity.facing === 'right' ? entity.x + 10 : entity.x - 3,
            y: entity.y,
            w: 3, h: 10,
            vx: entity.facing === 'right' ? BULLET_SPEED : -BULLET_SPEED,
            owner: entity.color
        });
        entity.cooldown = 1.0; // 1 second cooldown
    }
}

function getShieldRect(entity) {
    if (entity.facing === 'right') return { x: entity.x + 15, y: entity.y + 3, w: 3, h: 10 };
    if (entity.facing === 'left') return { x: entity.x - 8, y: entity.y + 3, w: 3, h: 10 };
    if (entity.facing === 'up') return { x: entity.x, y: entity.y - 8, w: 10, h: 3 };
    if (entity.facing === 'down') return { x: entity.x, y: entity.y + 15, w: 10, h: 3 };
}

function updateAI(dt) {
    enemy.stateTimer -= dt;
    enemy.vx = 0;
    enemy.shielding = false;

    // Detect incoming bullets
    let incoming = bullets.find(b => b.owner === 'blue' && Math.abs(b.y - enemy.y) < 20 && Math.abs(b.x - enemy.x) < 100);
    
    if (incoming) {
        // AI Defense
        if (incoming.x < enemy.x) enemy.facing = 'left';
        if (Math.random() < 0.5 && enemy.grounded) {
            enemy.vy = JUMP_VELOCITY; // Dodge jump
        } else {
            enemy.shielding = true; // Block
        }
    } else {
        // AI Offense & Movement
        if (enemy.stateTimer <= 0) {
            enemy.stateTimer = Math.random() * 2;
            let action = Math.random();
            if (action < 0.3) enemy.facing = 'left';
            else if (action < 0.6) enemy.facing = 'right';
            else if (action < 0.8 && enemy.grounded) enemy.vy = JUMP_VELOCITY;
        }
        
        if (enemy.facing === 'left') enemy.vx = -MOVE_SPEED;
        if (enemy.facing === 'right') enemy.vx = MOVE_SPEED;

        // Shoot if player is roughly in front
        if ((enemy.facing === 'left' && player.x < enemy.x) || (enemy.facing === 'right' && player.x > enemy.x)) {
            shoot(enemy);
        }
    }
}

function update(dt) {
    if (keys['r']) resetGame();
    if (player.hp <= 0 || enemy.hp <= 0) return; // Game over state

    // Player Input
    player.vx = 0;
    player.shielding = keys['x'];
    
    if (keys['a'] || keys['arrowleft']) { player.vx = -MOVE_SPEED; if(player.shielding) player.facing = 'left'; else if(!player.shielding) player.facing = 'left'; }
    if (keys['d'] || keys['arrowright']) { player.vx = MOVE_SPEED; if(player.shielding) player.facing = 'right'; else if(!player.shielding) player.facing = 'right'; }
    if (player.shielding && (keys['w'] || keys['arrowup'])) player.facing = 'up';
    if (player.shielding && (keys['s'] || keys['arrowdown'])) player.facing = 'down';

    // Player Jump & Shoot
    if (!player.shielding && (keys['w'] || keys['arrowup']) && player.grounded) player.vy = JUMP_VELOCITY;
    if (keys['z']) shoot(player);

    player.cooldown -= dt;
    enemy.cooldown -= dt;

    updatePhysics(player, dt);
    updateAI(dt);
    updatePhysics(enemy, dt);

    // Bullet logic
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx * dt;

        // Check shield blocks
        let playerShield = player.shielding ? getShieldRect(player) : null;
        let enemyShield = enemy.shielding ? getShieldRect(enemy) : null;

        if (playerShield && rectIntersect(b, playerShield) && b.owner !== 'blue') { bullets.splice(i, 1); continue; }
        if (enemyShield && rectIntersect(b, enemyShield) && b.owner !== 'red') { bullets.splice(i, 1); continue; }

        // Check body hits
        if (b.owner !== 'blue' && rectIntersect(b, player)) { player.hp--; bullets.splice(i, 1); continue; }
        if (b.owner !== 'red' && rectIntersect(b, enemy)) { enemy.hp--; bullets.splice(i, 1); continue; }

        // Screen bounds
        if (b.x < 0 || b.x > canvas.width) bullets.splice(i, 1);
    }
}

function drawRect(rect, color) {
    ctx.fillStyle = color;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
}

function drawHearts(x, y, hp, color) {
    ctx.fillStyle = color;
    ctx.font = '16px Arial';
    ctx.fillText('â¤'.repeat(Math.max(0, hp)), x, y);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Platforms
    platforms.forEach(p => drawRect(p, '#444'));

    // Draw Entities
    if (player.hp > 0) {
        drawRect(player, player.color);
        if (player.shielding) drawRect(getShieldRect(player), '#00ffff');
    }
    
    if (enemy.hp > 0) {
        drawRect(enemy, enemy.color);
        if (enemy.shielding) drawRect(getShieldRect(enemy), '#ff8888');
    }

    // Draw Bullets
    bullets.forEach(b => drawRect(b, '#ffff00'));

    // Draw UI
    drawHearts(20, 30, player.hp, 'blue');
    drawHearts(520, 30, enemy.hp, 'red');

    if (player.hp <= 0) { ctx.fillStyle = 'white'; ctx.fillText('RED WINS! Press R to Restart', 220, 200); }
    if (enemy.hp <= 0) { ctx.fillStyle = 'white'; ctx.fillText('BLUE WINS! Press R to Restart', 220, 200); }
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    // Cap delta time to prevent physics breaking if tab is inactive
    if (dt > 0.1) dt = 0.1;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
