<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue vs Red: Dash & Islands Update</title>
    <style>
        body { background-color: #222; color: white; text-align: center; font-family: sans-serif; }
        canvas { background-color: #111; border: 2px solid #555; margin-top: 20px; box-shadow: 0 0 10px #000; }
        p { max-width: 800px; margin: 10px auto; line-height: 1.5; color: #aaa; }
    </style>
</head>
<body>

    <h2>Blue vs Red Box (Dash & Islands)</h2>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <p><strong>Controls:</strong> WASD/Arrows to move. W/Up to jump (double & wall jump). <strong>C</strong> to dash. <strong>Z</strong> to shoot. <strong>X</strong> to shield. <strong>R</strong> to reset.</p>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Physics & Ability Variables
const MOVE_SPEED = 180; 
const GRAVITY = 900;    
const JUMP_VELOCITY = -350; 
const BULLET_SPEED = 500; 
const DASH_SPEED = 600;
const DASH_DURATION = 0.15;
const DASH_COOLDOWN = 1.5;

let keys = {};
let prevKeys = {}; 
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

let player, enemy, bullets, platforms, lastTime;

function resetGame() {
    player = { x: 50, y: 500, w: 10, h: 10, vx: 0, vy: 0, hp: 5, facing: 'right', shielding: false, cooldown: 0, dashTime: 0, dashCd: 0, color: 'blue', jumps: 0, onWall: 0 };
    enemy = { x: 740, y: 500, w: 10, h: 10, vx: 0, vy: 0, hp: 5, facing: 'left', shielding: false, cooldown: 0, color: 'red', stateTimer: 0, jumps: 0, onWall: 0 };
    bullets = [];
    
    // Expanded Island Layout
    platforms = [
        { x: 0, y: 570, w: 800, h: 30 }, // Floor
        { x: 100, y: 460, w: 100, h: 10 },
        { x: 350, y: 480, w: 100, h: 10 },
        { x: 600, y: 460, w: 100, h: 10 },
        { x: 220, y: 350, w: 100, h: 10 },
        { x: 480, y: 350, w: 100, h: 10 },
        { x: 350, y: 240, w: 100, h: 10 },
        { x: 80, y: 150, w: 100, h: 10 },
        { x: 620, y: 150, w: 100, h: 10 }
    ];
}

function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
}

function updatePhysics(entity, dt) {
    entity.x += entity.vx * dt;
    
    // Normal gravity if not dashing
    if (entity.dashTime === undefined || entity.dashTime <= 0) {
        entity.vy += GRAVITY * dt;
    }
    entity.y += entity.vy * dt;

    entity.grounded = false;
    entity.onWall = 0; // 0 = no, -1 = left wall, 1 = right wall

    // Screen bounds & Wall Jump detection
    if (entity.x <= 0) { entity.x = 0; entity.onWall = -1; }
    if (entity.x + entity.w >= canvas.width) { entity.x = canvas.width - entity.w; entity.onWall = 1; }

    // Platform Collisions (Floor only to allow jumping up through them)
    platforms.forEach(p => {
        if (rectIntersect(entity, p) && entity.vy > 0 && entity.y + entity.h - (entity.vy * dt) <= p.y + 10) {
            entity.y = p.y - entity.h;
            entity.vy = 0;
            entity.grounded = true;
            entity.jumps = 0; 
        }
    });

    if (entity.y < 0) { entity.y = 0; entity.vy = 0; }
}

function shoot(entity) {
    if (entity.cooldown <= 0) {
        bullets.push({
            x: entity.facing === 'right' ? entity.x + 12 : entity.x - 12,
            y: entity.y + 3,
            w: 10, h: 3, 
            vx: entity.facing === 'right' ? BULLET_SPEED : -BULLET_SPEED,
            owner: entity.color
        });
        entity.cooldown = 0.4; 
    }
}

function getShieldRect(entity) {
    if (entity.facing === 'right') return { x: entity.x + 15, y: entity.y - 3, w: 3, h: 16 };
    if (entity.facing === 'left') return { x: entity.x - 8, y: entity.y - 3, w: 3, h: 16 };
    if (entity.facing === 'up') return { x: entity.x - 3, y: entity.y - 8, w: 16, h: 3 };
    if (entity.facing === 'down') return { x: entity.x - 3, y: entity.y + 15, w: 16, h: 3 };
}

function updateAI(dt) {
    enemy.stateTimer -= dt;
    enemy.vx = 0;
    enemy.shielding = false;

    // AI Wall Jump Logic
    if (enemy.onWall !== 0 && !enemy.grounded && enemy.vy > 0 && Math.random() < 0.05) {
        enemy.vy = JUMP_VELOCITY * 0.9;
        enemy.facing = enemy.onWall === -1 ? 'right' : 'left';
    }

    let incoming = bullets.find(b => b.owner === 'blue' && Math.abs(b.y - enemy.y) < 20 && Math.abs(b.x - enemy.x) < 150);
    
    if (incoming) {
        if (incoming.x < enemy.x) enemy.facing = 'left';
        if (Math.random() < 0.4 && enemy.grounded) {
            enemy.vy = JUMP_VELOCITY;
        } else {
            enemy.shielding = true;
        }
    } else {
        if (enemy.stateTimer <= 0) {
            enemy.stateTimer = Math.random();
            let action = Math.random();
            if (action < 0.4) enemy.facing = 'left';
            else if (action < 0.8) enemy.facing = 'right';
            else if (enemy.grounded) { enemy.vy = JUMP_VELOCITY; enemy.jumps = 1; }
        }
        
        if (enemy.facing === 'left') enemy.vx = -MOVE_SPEED;
        if (enemy.facing === 'right') enemy.vx = MOVE_SPEED;

        if ((enemy.facing === 'left' && player.x < enemy.x) || (enemy.facing === 'right' && player.x > enemy.x)) {
            shoot(enemy);
        }
    }
}

function update(dt) {
    if (keys['r']) resetGame();
    if (player.hp <= 0 || enemy.hp <= 0) return;

    // Dash Logic
    if (keys['c'] && player.dashCd <= 0) {
        player.dashTime = DASH_DURATION;
        player.dashCd = DASH_COOLDOWN;
    }

    player.vx = 0;
    player.shielding = keys['x'] && !keys['z']; 

    if (player.dashTime > 0) {
        // While dashing, ignore regular input and speed forward
        player.vx = player.facing === 'left' ? -DASH_SPEED : DASH_SPEED;
        player.vy = 0; // Suspend gravity during dash
        player.dashTime -= dt;
        player.shielding = false; // Cannot shield while dashing
    } else {
        // Regular Movement
        if (keys['a'] || keys['arrowleft']) { player.vx = -MOVE_SPEED; player.facing = 'left'; }
        if (keys['d'] || keys['arrowright']) { player.vx = MOVE_SPEED; player.facing = 'right'; }
        if (player.shielding && (keys['w'] || keys['arrowup'])) player.facing = 'up';
        if (player.shielding && (keys['s'] || keys['arrowdown'])) player.facing = 'down';

        // Jump Logic
        let jumpKey = keys['w'] || keys['arrowup'];
        let prevJumpKey = prevKeys['w'] || prevKeys['arrowup'];

        if (!player.shielding && jumpKey && !prevJumpKey) {
            if (player.grounded) {
                player.vy = JUMP_VELOCITY;
                player.jumps = 1;
            } else if (player.onWall !== 0) {
                player.vy = JUMP_VELOCITY * 0.9;
                player.vx = player.onWall === -1 ? MOVE_SPEED * 1.5 : -MOVE_SPEED * 1.5;
            } else if (player.jumps < 2) {
                player.vy = JUMP_VELOCITY * 0.8;
                player.jumps = 2;
            }
        }
    }

    if (keys['z']) shoot(player);

    player.cooldown -= dt;
    player.dashCd -= dt;
    enemy.cooldown -= dt;

    updatePhysics(player, dt);
    updateAI(dt);
    updatePhysics(enemy, dt);

    // Bullet logic
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx * dt;

        let playerShield = player.shielding ? getShieldRect(player) : null;
        let enemyShield = enemy.shielding ? getShieldRect(enemy) : null;

        if (playerShield && rectIntersect(b, playerShield) && b.owner !== 'blue') { bullets.splice(i, 1); continue; }
        if (enemyShield && rectIntersect(b, enemyShield) && b.owner !== 'red') { bullets.splice(i, 1); continue; }

        if (b.owner !== 'blue' && rectIntersect(b, player)) { player.hp--; bullets.splice(i, 1); continue; }
        if (b.owner !== 'red' && rectIntersect(b, enemy)) { enemy.hp--; bullets.splice(i, 1); continue; }

        if (b.x < 0 || b.x > canvas.width) bullets.splice(i, 1);
    }

    Object.assign(prevKeys, keys);
}

function drawRect(rect, color) {
    ctx.fillStyle = color;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
}

function drawHearts(x, y, hp, color) {
    ctx.fillStyle = color;
    ctx.font = '20px Arial';
    ctx.fillText('â¤'.repeat(Math.max(0, hp)), x, y);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Platforms
    platforms.forEach(p => drawRect(p, '#444'));

    // Draw Player
    if (player.hp > 0) {
        // Make the player flash white while dashing
        drawRect(player, player.dashTime > 0 ? 'white' : player.color);
        if (player.shielding) drawRect(getShieldRect(player), '#00ffff');
    }
    
    // Draw Enemy
    if (enemy.hp > 0) {
        drawRect(enemy, enemy.color);
        if (enemy.shielding) drawRect(getShieldRect(enemy), '#ff8888');
    }

    // Draw Bullets
    bullets.forEach(b => drawRect(b, '#ffff00'));

    // Draw UI
    drawHearts(20, 30, player.hp, '#4488ff');
    drawHearts(canvas.width - 120, 30, enemy.hp, '#ff4444');

    // Dash Cooldown Indicator
    if (player.dashCd > 0) {
        ctx.fillStyle = '#888';
        ctx.font = '12px Arial';
        ctx.fillText('Dash CD', 20, 50);
        ctx.fillRect(20, 55, 60 * (1 - (player.dashCd / DASH_COOLDOWN)), 4);
    } else {
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText('Dash READY', 20, 50);
    }

    if (player.hp <= 0) { ctx.fillStyle = 'white'; ctx.font = '24px Arial'; ctx.fillText('RED WINS! Press R to Restart', 230, 300); }
    if (enemy.hp <= 0) { ctx.fillStyle = 'white'; ctx.font = '24px Arial'; ctx.fillText('BLUE WINS! Press R to Restart', 230, 300); }
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (dt > 0.1) dt = 0.1;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
