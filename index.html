<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue vs Red: Fast Brawler</title>
    <style>
        body { background-color: #222; color: white; text-align: center; font-family: sans-serif; }
        canvas { background-color: #111; border: 2px solid #555; margin-top: 20px; box-shadow: 0 0 10px #000; }
        p { max-width: 600px; margin: 10px auto; line-height: 1.5; color: #aaa; }
    </style>
</head>
<body>

    <h2>Blue vs Red Box (Speed Update)</h2>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <p><strong>Controls:</strong> WASD/Arrows to move. W/Up to jump (can double jump & wall jump on screen edges). <strong>Z</strong> to shoot. <strong>X</strong> to shield. <strong>R</strong> to reset.</p>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Upgraded Physics Variables
const MOVE_SPEED = 180; 
const GRAVITY = 900;    
const JUMP_VELOCITY = -350; 
const BULLET_SPEED = 500; 

let keys = {};
let prevKeys = {}; // Used to detect single key presses for jumping
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

let player, enemy, bullets, platforms, lastTime;

function resetGame() {
    player = { x: 50, y: 300, w: 10, h: 10, vx: 0, vy: 0, hp: 5, facing: 'right', shielding: false, cooldown: 0, color: 'blue', jumps: 0, onWall: 0 };
    enemy = { x: 540, y: 300, w: 10, h: 10, vx: 0, vy: 0, hp: 5, facing: 'left', shielding: false, cooldown: 0, color: 'red', stateTimer: 0, jumps: 0, onWall: 0 };
    bullets = [];
    platforms = [
        { x: 0, y: 370, w: 600, h: 30 }, // Ground
        { x: 100, y: 280, w: 120, h: 10 },
        { x: 380, y: 280, w: 120, h: 10 },
        { x: 240, y: 180, w: 120, h: 10 }
    ];
}

function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
}

function updatePhysics(entity, dt) {
    entity.x += entity.vx * dt;
    entity.vy += GRAVITY * dt;
    entity.y += entity.vy * dt;

    entity.grounded = false;
    entity.onWall = 0; // 0 = no, -1 = left wall, 1 = right wall

    // Screen bounds & Wall Jump detection
    if (entity.x <= 0) { entity.x = 0; entity.onWall = -1; }
    if (entity.x + entity.w >= canvas.width) { entity.x = canvas.width - entity.w; entity.onWall = 1; }

    // Platform Collisions (Floor only)
    platforms.forEach(p => {
        if (rectIntersect(entity, p) && entity.vy > 0 && entity.y + entity.h - (entity.vy * dt) <= p.y + 5) {
            entity.y = p.y - entity.h;
            entity.vy = 0;
            entity.grounded = true;
            entity.jumps = 0; // Reset double jump
        }
    });

    if (entity.y < 0) { entity.y = 0; entity.vy = 0; }
}

function shoot(entity) {
    if (entity.cooldown <= 0) {
        bullets.push({
            x: entity.facing === 'right' ? entity.x + 12 : entity.x - 12,
            y: entity.y + 3,
            w: 10, h: 3, // Wider horizontally
            vx: entity.facing === 'right' ? BULLET_SPEED : -BULLET_SPEED,
            owner: entity.color
        });
        entity.cooldown = 0.4; // Faster shooting cooldown
    }
}

function getShieldRect(entity) {
    // Taller vertically (3x16 instead of 3x10)
    if (entity.facing === 'right') return { x: entity.x + 15, y: entity.y - 3, w: 3, h: 16 };
    if (entity.facing === 'left') return { x: entity.x - 8, y: entity.y - 3, w: 3, h: 16 };
    if (entity.facing === 'up') return { x: entity.x - 3, y: entity.y - 8, w: 16, h: 3 };
    if (entity.facing === 'down') return { x: entity.x - 3, y: entity.y + 15, w: 16, h: 3 };
}

function updateAI(dt) {
    enemy.stateTimer -= dt;
    enemy.vx = 0;
    enemy.shielding = false;

    let incoming = bullets.find(b => b.owner === 'blue' && Math.abs(b.y - enemy.y) < 20 && Math.abs(b.x - enemy.x) < 150);
    
    if (incoming) {
        if (incoming.x < enemy.x) enemy.facing = 'left';
        if (Math.random() < 0.4 && enemy.grounded) {
            enemy.vy = JUMP_VELOCITY;
        } else {
            enemy.shielding = true;
        }
    } else {
        if (enemy.stateTimer <= 0) {
            enemy.stateTimer = Math.random();
            let action = Math.random();
            if (action < 0.4) enemy.facing = 'left';
            else if (action < 0.8) enemy.facing = 'right';
            else if (enemy.grounded) { enemy.vy = JUMP_VELOCITY; enemy.jumps = 1; }
        }
        
        if (enemy.facing === 'left') enemy.vx = -MOVE_SPEED;
        if (enemy.facing === 'right') enemy.vx = MOVE_SPEED;

        if ((enemy.facing === 'left' && player.x < enemy.x) || (enemy.facing === 'right' && player.x > enemy.x)) {
            shoot(enemy);
        }
    }
}

function update(dt) {
    if (keys['r']) resetGame();
    if (player.hp <= 0 || enemy.hp <= 0) return;

    // Player Input
    player.vx = 0;
    
    // Shield only activates if NOT shooting
    player.shielding = keys['x'] && !keys['z']; 
    
    if (keys['a'] || keys['arrowleft']) { player.vx = -MOVE_SPEED; player.facing = 'left'; }
    if (keys['d'] || keys['arrowright']) { player.vx = MOVE_SPEED; player.facing = 'right'; }
    if (player.shielding && (keys['w'] || keys['arrowup'])) player.facing = 'up';
    if (player.shielding && (keys['s'] || keys['arrowdown'])) player.facing = 'down';

    // Jump Logic (Single, Double, Wall)
    let jumpKey = keys['w'] || keys['arrowup'];
    let prevJumpKey = prevKeys['w'] || prevKeys['arrowup'];

    if (!player.shielding && jumpKey && !prevJumpKey) {
        if (player.grounded) {
            player.vy = JUMP_VELOCITY;
            player.jumps = 1;
        } else if (player.onWall !== 0) {
            // Wall Jump off screen edges
            player.vy = JUMP_VELOCITY * 0.9;
            player.vx = player.onWall === -1 ? MOVE_SPEED * 1.5 : -MOVE_SPEED * 1.5;
        } else if (player.jumps < 2) {
            // Double Jump
            player.vy = JUMP_VELOCITY * 0.8;
            player.jumps = 2;
        }
    }

    if (keys['z']) shoot(player);

    player.cooldown -= dt;
    enemy.cooldown -= dt;

    updatePhysics(player, dt);
    updateAI(dt);
    updatePhysics(enemy, dt);

    // Bullet logic
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx * dt;

        let playerShield = player.shielding ? getShieldRect(player) : null;
        let enemyShield = enemy.shielding ? getShieldRect(enemy) : null;

        if (playerShield && rectIntersect(b, playerShield) && b.owner !== 'blue') { bullets.splice(i, 1); continue; }
        if (enemyShield && rectIntersect(b, enemyShield) && b.owner !== 'red') { bullets.splice(i, 1); continue; }

        if (b.owner !== 'blue' && rectIntersect(b, player)) { player.hp--; bullets.splice(i, 1); continue; }
        if (b.owner !== 'red' && rectIntersect(b, enemy)) { enemy.hp--; bullets.splice(i, 1); continue; }

        if (b.x < 0 || b.x > canvas.width) bullets.splice(i, 1);
    }

    // Save current keys for next frame to detect single presses
    Object.assign(prevKeys, keys);
}

function drawRect(rect, color) {
    ctx.fillStyle = color;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
}

function drawHearts(x, y, hp, color) {
    ctx.fillStyle = color;
    ctx.font = '16px Arial';
    ctx.fillText('â¤'.repeat(Math.max(0, hp)), x, y);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    platforms.forEach(p => drawRect(p, '#444'));

    if (player.hp > 0) {
        drawRect(player, player.color);
        if (player.shielding) drawRect(getShieldRect(player), '#00ffff');
    }
    
    if (enemy.hp > 0) {
        drawRect(enemy, enemy.color);
        if (enemy.shielding) drawRect(getShieldRect(enemy), '#ff8888');
    }

    bullets.forEach(b => drawRect(b, '#ffff00'));

    drawHearts(20, 30, player.hp, 'blue');
    drawHearts(520, 30, enemy.hp, 'red');

    if (player.hp <= 0) { ctx.fillStyle = 'white'; ctx.fillText('RED WINS! Press R to Restart', 220, 200); }
    if (enemy.hp <= 0) { ctx.fillStyle = 'white'; ctx.fillText('BLUE WINS! Press R to Restart', 220, 200); }
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (dt > 0.1) dt = 0.1;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
